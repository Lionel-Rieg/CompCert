#include <assert.h>
#include "heater_control.h"

/* C code generated by lustrec
   Version number 1.6-@GITBRANCH@
   Code is C99 compliant
   Using (double) floating-point numbers */
   
/* Import dependencies */

/* Global constants (definitions) */
double FAILURE = -999.0;
double TMIN = 6.0;
double TMAX = 9.0;
double DELTA = 0.5;

/* Struct definitions */
struct not_a_sauna2_mem {struct not_a_sauna2_reg {double __not_a_sauna2_2;
                                                  } _reg; 
                         struct _arrow_mem *ni_0;
                         };
struct heater_control_mem {struct heater_control_reg {_Bool __heater_control_16;
                                                      } _reg; 
                           struct _arrow_mem *ni_1;
                           };
struct not_a_sauna_mem {struct not_a_sauna_reg {double __not_a_sauna_2;
                                                } _reg; 
                        struct _arrow_mem *ni_2;
                        };


void not_a_sauna2_reset (struct not_a_sauna2_mem *self) {
  
  _arrow_reset(self->ni_0);
  return;
}

void not_a_sauna2_step (double T, double T1, double T2, double T3,
                        _Bool Heat_on, 
                        _Bool (*ok),
                        struct not_a_sauna2_mem *self) {
  _Bool __not_a_sauna2_1;
  
  
  _arrow_step (1, 0, &__not_a_sauna2_1, self->ni_0);
  if (__not_a_sauna2_1) {
    *ok = 1;
  } else {
    *ok = (self->_reg.__not_a_sauna2_2 < (9.0 - 6.0));
  }
  self->_reg.__not_a_sauna2_2 = T;
  
  return;
}

void heater_control_reset (struct heater_control_mem *self) {
  
  _arrow_reset(self->ni_1);
  return;
}

void heater_control_step (double T, double T1, double T2, double T3, 
                          _Bool (*Heat_on),
                          struct heater_control_mem *self) {
  double Median_42_max2_150_m;
  double Median_42_max2_152_m;
  double Median_42_min2_141_m;
  double Median_42_min2_143_m;
  double Median_52_max2_150_m;
  double Median_52_max2_152_m;
  double Median_52_min2_141_m;
  double Median_52_min2_143_m;
  double Tguess;
  _Bool V12;
  _Bool V13;
  _Bool V23;
  _Bool __heater_control_12;
  double abs_15_a;
  double abs_15_v;
  double abs_23_a;
  double abs_23_v;
  double abs_7_a;
  double abs_7_v;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  abs_7_v = (T1 - T2);
  if ((abs_7_v >= 0.0)) {
    abs_7_a = abs_7_v;
  } else {
    abs_7_a = (- abs_7_v);
  }
  abs_23_v = (T2 - T3);
  if ((abs_23_v >= 0.0)) {
    abs_23_a = abs_23_v;
  } else {
    abs_23_a = (- abs_23_v);
  }
  abs_15_v = (T1 - T3);
  if ((abs_15_v >= 0.0)) {
    abs_15_a = abs_15_v;
  } else {
    abs_15_a = (- abs_15_v);
  }
  V23 = (abs_23_a < 0.5);
  V13 = (abs_15_a < 0.5);
  V12 = (abs_7_a < 0.5);
  if ((T2 < T3)) {
    Median_52_min2_141_m = T2;
  } else {
    Median_52_min2_141_m = T3;
  }
  if ((T2 > T3)) {
    Median_42_max2_150_m = T2;
  } else {
    Median_42_max2_150_m = T3;
  }
  if ((T2 < T3)) {
    Median_42_min2_141_m = T2;
  } else {
    Median_42_min2_141_m = T3;
  }
  if ((T2 > T3)) {
    Median_52_max2_150_m = T2;
  } else {
    Median_52_max2_150_m = T3;
  }
  if ((T1 < Median_52_min2_141_m)) {
    Median_52_min2_143_m = T1;
  } else {
    Median_52_min2_143_m = Median_52_min2_141_m;
  }
  if ((T1 > Median_52_max2_150_m)) {
    Median_52_max2_152_m = T1;
  } else {
    Median_52_max2_152_m = Median_52_max2_150_m;
  }
  if ((T1 < Median_42_min2_141_m)) {
    Median_42_min2_143_m = T1;
  } else {
    Median_42_min2_143_m = Median_42_min2_141_m;
  }
  if ((T1 > Median_42_max2_150_m)) {
    Median_42_max2_152_m = T1;
  } else {
    Median_42_max2_152_m = Median_42_max2_150_m;
  }
  if ((((!V12) && (!V13)) && (!V23))) {
    Tguess = -999.0;
  } else {
    if (((((V12 && (!V13)) && (!V23)) || ((V13 && (!V12)) && (!V23))) || ((V23 && (!V12)) && (!V13)))) {
      Tguess = ((((T1 + T2) + T3) - Median_42_min2_143_m) - Median_42_max2_152_m);
    } else {
      if (((V12 && V13) && V23)) {
        Tguess = ((((T1 + T2) + T3) - Median_52_min2_143_m) - Median_52_max2_152_m);
      } else {
        if (V12) {
          Tguess = ((T1 + T2) / 2.0);
        } else {
          if (V13) {
            Tguess = ((T1 + T3) / 2.0);
          } else {
            Tguess = ((T2 + T3) / 2.0);
          }
        }
      }
    }
  }
  _arrow_step (1, 0, &__heater_control_12, self->ni_1);
  if (__heater_control_12) {
    *Heat_on = 1;
  } else {
    if ((Tguess == -999.0)) {
      *Heat_on = 0;
    } else {
      if ((Tguess < 6.0)) {
        *Heat_on = 1;
      } else {
        if ((Tguess > 9.0)) {
          *Heat_on = 0;
        } else {
          *Heat_on = self->_reg.__heater_control_16;
        }
      }
    }
  }
  self->_reg.__heater_control_16 = *Heat_on;
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  return;
}

void not_a_sauna_reset (struct not_a_sauna_mem *self) {
  
  _arrow_reset(self->ni_2);
  return;
}

void not_a_sauna_step (double T, double T1, double T2, double T3,
                       _Bool Heat_on, 
                       _Bool (*ok),
                       struct not_a_sauna_mem *self) {
  _Bool __not_a_sauna_1;
  
  
  _arrow_step (1, 0, &__not_a_sauna_1, self->ni_2);
  if (__not_a_sauna_1) {
    *ok = 1;
  } else {
    *ok = (self->_reg.__not_a_sauna_2 < (9.0 + 1.0));
  }
  self->_reg.__not_a_sauna_2 = T;
  
  return;
}

void oneoftree_step (_Bool f1, _Bool f2, _Bool f3, 
                     _Bool (*r)
                     ) {
  
  *r = ((((f1 && (!f2)) && (!f3)) || ((f2 && (!f1)) && (!f3))) || ((f3 && (!f1)) && (!f2)));
  return;
}

void noneoftree_step (_Bool f1, _Bool f2, _Bool f3, 
                      _Bool (*r)
                      ) {
  
  *r = (((!f1) && (!f2)) && (!f3));
  return;
}

void alloftree_step (_Bool f1, _Bool f2, _Bool f3, 
                     _Bool (*r)
                     ) {
  
  *r = ((f1 && f2) && f3);
  return;
}

void abs_step (double v, 
               double (*a)
               ) {
  
  if ((v >= 0.0)) {
    *a = v;
  } else {
    *a = (- v);
  }
  return;
}

void Median_step (double a, double b, double c, 
                  double (*z)
                  ) {
  double __Median_1;
  double __Median_2;
  double __Median_3;
  double __Median_4;
  
  
  
  
  
  min2_step (b, c, &__Median_3);
  min2_step (a, __Median_3, &__Median_4);
  max2_step (b, c, &__Median_1);
  max2_step (a, __Median_1, &__Median_2);
  *z = ((((a + b) + c) - __Median_4) - __Median_2);
  
  
  
  
  return;
}

void Average_step (double a, double b, 
                   double (*z)
                   ) {
  
  *z = ((a + b) / 2.0);
  return;
}

void min2_step (double one, double two, 
                double (*m)
                ) {
  
  if ((one < two)) {
    *m = one;
  } else {
    *m = two;
  }
  return;
}

void max2_step (double one, double two, 
                double (*m)
                ) {
  
  if ((one > two)) {
    *m = one;
  } else {
    *m = two;
  }
  return;
}

